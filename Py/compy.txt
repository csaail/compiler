#Design a program to convert the given Right Linear Grammar into Left Linear Grammar
#A=cB, S=eF, A=cB

def print_productions():
    print("Saail Chavan KFPMSCCS016")
    
    n = int(input("Enter the number of productions you want to convert: "))
    
    prod = []
    for i in range(n):
        prod.append(input(f"\nEnter production number {i + 1} in the form of (X = bY): ")) 
    
    print("\n\nThe number of productions are as below:")
    for i in range(n):
        print(f"{i + 1}) {prod[i]}")
    
    print("\n\nLeft linear grammar is -->")
    for i in range(n):
        left, right = prod[i].split('=') 
        print(f"{left.strip()} --> {right.strip()}") 


if __name__ == "__main__":
    print_productions()



#Design a program to check given input is identifier, constants, reserved keywords, and operators.
#Identifier
#compiler, Saail_Chavan
#124_compiler, @saail

def is_valid_identifier(s):
    # Check if the first character is a letter
    if not (('a' <= s[0] <= 'z') or ('A' <= s[0] <= 'Z')):
        return False

    # Traverse the string for the rest of the characters
    for i in range(1, len(s)):
        if not (('a' <= s[i] <= 'z') or ('A' <= s[i] <= 'Z') or ('0' <= s[i] <= '9') or s[i] == '_'):
            return False

    # String is a valid identifier
    return True


if __name__ == "__main__":
    print("Saail Chavan KFPMSCCS016")
    str_input = input("Enter a string: ")

    if is_valid_identifier(str_input):
        print("Identifier")
    else:
        print("Not an Identifier")



#Design a program to check given input is identifier, constants, reserved keywords, and operators.
#12345,  124asf
#Constants

def pcon():
    flag = True
    str_input = input("Enter the string: ")

    # Check if all characters are digits
    for char in str_input:
        if not ('0' <= char <= '9'):
            flag = False
            break

    # Print the result based on the flag
    if flag:
        print("Constant")
    else:
        print("Not a Constant")


if __name__ == "__main__":
    print("Saail Chavan KFPMSCCS016")
    pcon()


#Design a program to check given input is identifier, constants, reserved keywords, and operators.
#>=  &&
#Operators

def opr():
    operators = ["+", "-", "/", "*", "<=", ">=", "<", ">", "==", "!="]
    str_input = input("Enter the operator: ")

    if str_input in operators:
        print("Operator")
    else:
        print("Not an Operator")


if __name__ == "__main__":
    print("Saail Chavan KFPMSCCS016")
    opr()



#Design a program to check given input is identifier, constants, reserved keywords, and operators.
#compiler, break
#Reserved keywords

def res():
    reserved_keywords = ["printf", "scanf", "if", "else", "break"]
    str_input = input("Enter the string: ")

    if str_input in reserved_keywords:
        print("Reserved Keyword")
    else:
        print("Not a Reserved Keyword")


if __name__ == "__main__":
    print("Saail Chavan KFPMSCCS016\n")
    res()


#Design a lexical analyzer to recognize the token defined by the given program.
#Saail Chavan, Saail007

def is_valid_identifier(s):
    # Check if the first character is a letter
    if not (('a' <= s[0] <= 'z') or ('A' <= s[0] <= 'Z')):
        return False

    # Traverse the string for the rest of the characters
    for char in s[1:]:
        if not (('a' <= char <= 'z') or ('A' <= char <= 'Z') or ('0' <= char <= '9') or char == '_'):
            return False

    # String is a valid identifier
    return True

def is_operator(s):
    operators = ["+", "-", "/", "*", "<=", ">=", "<", ">", "==", "!="]
    return s in operators

def is_punctuation(s):
    punctuations = [".", ",", ";", "(", ")", "{", "}", "[", "]"]
    return s in punctuations

def is_reserved_keyword(s):
    reserved_keywords = ["printf", "scanf", "if", "else", "break"]
    return s in reserved_keywords

def is_constant(s):
    # Check if all characters are digits
    for char in s:
        if not ('0' <= char <= '9'):
            return False
    return True

def main():
    str_input = input("Enter a string: ")
    # Check if the string is a valid identifier, reserved keyword, operator, punctuation, or constant
    if (is_valid_identifier(str_input) or is_reserved_keyword(str_input) or
            is_punctuation(str_input) or is_operator(str_input) or is_constant(str_input)):
        print(f"{str_input} is a Token")
    else:
        print(f"{str_input} is Not a Token")

if __name__ == "__main__":
    main()


#Design a program to minimize the given DFA.

def state_no(cc, dfa):
    return next((i for i in range(5) if dfa[i][0] == cc), -1)

def main():
    dfa = [['A', 'B', 'C'], ['B', 'B', 'D'], ['C', 'B', 'C'], ['D', 'B', 'E'], ['E', 'B', 'C']]
    final_state, group = ['E'], [[""] * 4 for _ in range(4)]
    
    print("Saail Chavan KFPMSCCS016\n********* DFA *******\n\ta\tb")
    for row in dfa: print("\t".join(row))
    
    for i in range(5):  # Find final states
        if dfa[i][1] == final_state[0] or dfa[i][2] == final_state[0]: final_state.append(dfa[i][0])
    
    final_state.sort()  # Sort final states

    for a in range(5):  # Grouping equivalent states
        for b in range(a + 1, 5):
            if dfa[a][1:] == dfa[b][1:]: group[a][0], group[a][1] = dfa[a][0], dfa[b][0]

    print("\n\n********** MIN DFA ***********\n\ta\tb")
    for fs in final_state:
        ff = state_no(fs, dfa)
        if ff != -1:
            if dfa[ff][1] == group[0][1]: dfa[ff][1] = group[0][0]
            if dfa[ff][2] == group[0][1]: dfa[ff][2] = group[0][0]
            print(f"{fs}\t{dfa[ff][1]}\t{dfa[ff][2]}")

if __name__ == "__main__":
    main()


#Practical 5: Design a program to develop Simple Precedence Matrix (SPM).
# S->aS, X->aX, B->!*

class Production:
    def __init__(self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs

def display(matrix, symbols):
    print("Display Matrix:")
    print(" ", " ".join(symbols))
    for i, row in enumerate(matrix):
        print(symbols[i], " ".join(map(str, row)))

def main():
    productions = []
    symbols = set()

    while True:
        lhs, rhs = input("\nEnter production (LHS RHS): ").split()
        productions.append(Production(lhs, rhs))
        symbols.add(lhs)
        symbols.update(rhs)
        ans = input("Continue? (y/n): ")
        if ans.lower() != 'y':
            break

    print("\nProductions are:")
    for prod in productions:
        print(f"{prod.lhs} -> {prod.rhs}")

    symbols = list(symbols)
    cnt = len(symbols)
    first = [[0] * cnt for _ in range(cnt)]
    last = [[0] * cnt for _ in range(cnt)]
    equals = [[0] * cnt for _ in range(cnt)]
    lt = [[0] * cnt for _ in range(cnt)]
    gt = [[0] * cnt for _ in range(cnt)]
    spm = [['0'] * cnt for _ in range(cnt)]

    # Compute FIRST matrix
    for prod in productions:
        lhs_index = symbols.index(prod.lhs)
        rhs_index = symbols.index(prod.rhs[0]) if prod.rhs else -1
        if rhs_index != -1:
            first[lhs_index][rhs_index] = 1

    print("\n\nFIRST MATRIX:")
    display(first, symbols)

    # Compute LAST matrix
    for prod in productions:
        lhs_index = symbols.index(prod.lhs)
        rhs_index = symbols.index(prod.rhs[-1]) if prod.rhs else -1
        if rhs_index != -1:
            last[lhs_index][rhs_index] = 1

    print("\n\nLAST MATRIX:")
    display(last, symbols)

    # Compute EQUALS matrix
    for prod in productions:
        for i in range(len(prod.rhs) - 1):
            lhs_index = symbols.index(prod.rhs[i])
            rhs_index = symbols.index(prod.rhs[i + 1])
            equals[lhs_index][rhs_index] = 1

    print("\n\nEQUALS MATRIX:")
    display(equals, symbols)

    # Compute LESS THAN matrix
    for i in range(cnt):
        for j in range(cnt):
            lt[i][j] = sum(equals[i][k] * first[k][j] for k in range(cnt))

    print("\n\nLESS THAN MATRIX:")
    display(lt, symbols)

    # Compute GREATER THAN matrix
    for i in range(cnt):
        for j in range(cnt):
            gt[i][j] = sum(last[k][i] * equals[k][j] for k in range(cnt))

    print("\n\nGREATER THAN MATRIX:")
    display(gt, symbols)

    # Build SPM matrix
    for i in range(cnt):
        for j in range(cnt):
            if lt[i][j] == 1:
                spm[i][j] = '<'
            elif gt[i][j] == 1:
                spm[i][j] = '>'
            elif equals[i][j] == 1:
                spm[i][j] = '='
            else:
                spm[i][j] = '0'  # No relation

    print("\n\nSPM MATRIX:")
    for row in spm:
        print(" ".join(row))

if __name__ == "__main__":
    main()





#Design a program to develop Operator Precedence Matrix (OPM).
#abc def

def display(matrix, symbols):
    # Print header row
    print("  ", " ".join(symbols))
    
    # Print matrix with corresponding symbol rows
    for i, sym in enumerate(symbols):
        print(f"{sym} ", " ".join(map(str, matrix[i])))

def main():
    productions = []
    first = [[0] * 20 for _ in range(20)]
    firstp = [[0] * 20 for _ in range(20)]
    firsts = [[0] * 20 for _ in range(20)]
    last = [[0] * 20 for _ in range(20)]
    lastp = [[0] * 20 for _ in range(20)]
    lasts = [[0] * 20 for _ in range(20)]
    equals = [[0] * 20 for _ in range(20)]
    lt = [[0] * 20 for _ in range(20)]
    gt = [[0] * 20 for _ in range(20)]
    opm = [['0'] * 20 for _ in range(20)]  # Operator precedence matrix
    symbols = []
    tot = 0
    
    ans = 'n'
    
    # Input productions
    while ans == 'n':
        print("Saail Chavan KFPMSCCS016")
        lhs = input("Enter LHS: ")
        rhs = input("Enter RHS: ")
        productions.append((lhs, rhs))
        tot += 1
        ans = input("\nContinue? (y/n): ").lower()

    # Display productions
    print("\nProductions are:")
    for lhs, rhs in productions:
        print(f"\n{lhs} -> {rhs}")

    # Extract unique symbols
    symbols.append(productions[0][0][0])
    
    for lhs, rhs in productions:
        if lhs[0] not in symbols:
            symbols.append(lhs[0])
        for char in rhs:
            if char not in symbols:
                symbols.append(char)

    # Display final symbols
    print("\n\nsym final:")
    print("\t", "\t".join(symbols))

    # Initialize matrices
    for i in range(20):
        for j in range(20):
            first[i][j] = firstp[i][j] = firsts[i][j] = last[i][j] = lastp[i][j] = lasts[i][j] = equals[i][j] = lt[i][j] = gt[i][j] = 0
            opm[i][j] = '0'  # Initialize operator precedence matrix

if __name__ == "__main__":
    main()







#Design a program to find FIRST and FOLLOW of all productions.
#abc, ;

def check_punctuator():
    punctuators = [".", ",", ";", "(", ")", "{", "}", "[", "]"]
    flag = False

    print("Enter the punctuator: ")
    user_input = input().strip()

    for punct in punctuators:
        if user_input == punct:
            flag = True
            break

    if flag:
        print("Punctuator")
    else:
        print("Not a Punctuator")

if __name__ == "__main__":
    print("Saail Chavan KFPMSCCS016")
    check_punctuator()



#Design a program to generate Directed Acyclic Graph (DAG)
# ab+bc, dg-hj+, q

class DAG:
    def __init__(self):
        self.i = self.j = self.k = 0
        self.count = -1
        self.str = [None] * 10  # Store input code sequences
        self.table = [[""] * 10 for _ in range(10)]  # Initialize table for DAG

        print("Saail Chavan KFPMSCCS016\n")
        print("Enter the sequence of code:")
        print("Enter 'q' to Quit")

        # Input the sequence of code lines
        for self.i in range(len(self.str)):
            self.str[self.i] = input()
            if self.str[self.i] == "q":
                break
            else:
                self.count += 1

        # Display the sequence of code
        print("\nThe sequence of code is:")
        for line in self.str:
            if line == "q":
                break
            print(line)

    def tablestruct(self):
        # Fill the table based on code
        for self.i in range(self.count + 1):
            if len(self.str[self.i]) == 3:  # Case for D=A
                self.table[self.i][0] = self.str[self.i][0]
                self.table[self.i][1] = self.str[self.i][1]
                self.table[self.i][2] = self.str[self.i][2]
            elif len(self.str[self.i]) == 5:  # Case for A=B+C
                self.table[self.i][0] = self.str[self.i][0]
                self.table[self.i][1] = self.str[self.i][3]
                self.table[self.i][2] = self.str[self.i][2]
                self.table[self.i][3] = self.str[self.i][4]

        # Optimization: Removing redundant computations
        for self.i in range(self.count + 1):
            for self.j in range(self.i + 1, self.count + 1):
                if len(self.str[self.i]) == 5 and len(self.str[self.j]) == 5:
                    if self.str[self.i][2:5] == self.str[self.j][2:5]:
                        self.table[self.i][0] += f",{self.str[self.j][0]}{self.str[self.j][4]}"
                        self.table[self.j] = [""] * 10

        # Handle case for D=A
        for self.i in range(self.count + 1):
            if len(self.str[self.i]) == 3:
                for self.j in range(self.count):
                    if self.str[self.i][2] == self.str[self.j][0]:
                        self.table[self.j][0] += f",{self.str[self.i][0]}"
                        self.table[self.i] = [""] * 10

        # Print the table
        print("\nLabel\tOperator\tLeft\tRight")
        for row in self.table[:self.count + 1]:
            print("\t".join(row[:self.count + 2]))

if __name__ == "__main__":
    dag = DAG()
    dag.tablestruct()




#Design a program to convert any expression into Three Address Code.
#ab+c-, ab+cd*-, sd-gh-kp++*

def generate_three_address_code(expr):
    sarr, code, j = [], [], 0
    print("Saail Chavan KFPMSCCS016")
    for c in expr:
        if c.isalnum():  # Operand
            sarr.append(c)
        elif c in '+-*/':  # Operator
            oprgt, oplft = sarr.pop(), sarr.pop()
            temp_var = f"T{j + 1}"
            print(f"{temp_var} = {oplft} {c} {oprgt}")
            sarr.append(temp_var)
            j += 1

if __name__ == "__main__":
    expr = input("Enter The Postfix Expression: ")
    generate_three_address_code(expr)



import time

def main():
    array1, array2, array3 = [10, 20, 30], [20, 10, 30], [40, 40, 10]

    t1 = time.time() * 1000
    for _ in range(10000000):
        sum_val = sum(array1) + sum(array2) + sum(array3)
        if sum_val != 210: print(False)
    t2 = time.time() * 1000

    for _ in range(10000000):
        sum_val = sum(array1[i] + array2[i] + array3[i] for i in range(len(array1)))
        if sum_val != 210: print(False)
    t3 = time.time() * 1000

    print("Saail Chavan KFPMSCCS016")
    print("Before loop jamming ---->", int(t2 - t1), "ms")
    print("After loop jamming ---->", int(t3 - t2), "ms")

if __name__ == "__main__":
    main()






import time

def main():
    array1 = [0] * 5

    t1 = time.time() * 1000
    # Version 1: Assign elements in a loop.
    for _ in range(10000000):
        for x in range(len(array1)):
            array1[x] = x
    t2 = time.time() * 1000

    # Version 2: Unroll the loop.
    for _ in range(10000000):
        array1[0], array1[1], array1[2], array1[3], array1[4] = 0, 1, 2, 3, 4
    t3 = time.time() * 1000

    print("Saail Chavan KFPMSCCS016")
    print("Time before loop unrolling: -->", int(t2 - t1), "ms")
    print("Time after loop unrolling: -->", int(t3 - t2), "ms")

if __name__ == "__main__":
    main()
